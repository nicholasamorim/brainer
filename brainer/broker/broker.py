import sys
import umsgpack

from twisted.python import log
from twisted.internet import reactor, defer

from txzmq import ZmqREPConnection, ZmqEndpoint, ZmqFactory

from replica import Publisher
from node_manager import NodeManager
from lib.mixins import SerializerMixin


class Broker(ZmqREPConnection, SerializerMixin):
    """
    """
    def __init__(self, factory, endpoint, *args, **kwargs):
        """
        :param factory: A `txzmq.ZmqFactory` object.
        :param endpoint: A `txzmq.ZmqEndpoint` object.
        :param node_manager: A Node Manager. Defaults to `NodeManager`.
        :param serializer: A serializer, defaults to umsgpack.
        :param debug: If True, will log debug messages. Defaults to False.
        """
        self._node_manager_class = kwargs.get('node_manager', NodeManager)
        self._node_manager = self._node_manager_class()
        self._serializer = kwargs.pop('serializer', umsgpack)
        self._debug = kwargs.pop('debug', False)

        log.msg('Broker started!!! Serializer: {}, Node Manager: {}'.format(
            self._serializer.__name__, self._node_manager_class.__name__))

        self._publisher = Publisher.create(
            kwargs.get('publisher_host', 'ipc:///tmp/publisher.sock'),
            debug=self._debug)

        super(Broker, self).__init__(factory, endpoint)

        self._allowed_actions = (
            'register', 'unregister', 'ping',
            'route', 'set', 'get', 'remove')

    @classmethod
    def create(cls, address, **kwargs):
        """Factory method to create a Broker.

        :param address: An address to bind the Broker.
        E.g.: ipc:///tmp/broker.sock
        :param node_manager: A Node Manager. Defaults to `NodeManager`.
        :param serializer: A serializer, defaults to umsgpack.
        :param debug: If True, will log debug messages. Defaults to False.
        """
        factory = ZmqFactory()
        endpoint = ZmqEndpoint('bind', address)
        return cls(factory, endpoint, **kwargs)

    def gotMessage(self, message_id, *messageParts):
        """Any message received is processed here.

        :param message_id: The message id (Generated by ZeroMQ).
        :param messageParts: The message itself.
        """
        message = self.unpack(messageParts[0])
        if self._debug:
            log.msg("New Message: {}".format(message))

        action = message['action']
        if action not in self._allowed_actions:
            self._reply_error("FORBBIDEN")

        method = getattr(self, action, None)
        if method is None:
            self._reply_error("NOT_IMPLEMENTED")

        method(message_id, message)

    def _reply_error(self, code, message=None):
        """Used when replying with an error.
        """
        return self.reply({"success": False, "code": code, "message": message})

    def reply(self, message_id, data):
        self._publisher.publish({"action": "CRAAZYY"}, tag=b'fanout')
        if self._debug:
            log.msg("Message Reply: {}".format(data))

        return super(Broker, self).reply(
            message_id, self._serializer.dumps(data))

    def register(self, message_id, message):
        node_number = self._node_manager.register(message['id'])
        self.reply(message_id, {"action": "register", "node": node_number})

    def unregister(self, message_id, message):
        node, server_id = message['node'], message['id']
        if self._debug:
            log.msg(
                'Unregister request received for node number {}'.format(node))
        self._node_manager.unregister(node, server_id)
        self.reply(message_id, {"action": "unregister", "unregistered": True})

    def ping(self, message_id, *messageParts):
        pass

    def pong(self, message_id, *messageParts):
        pass

    def route(self, message_id, *messageParts):
        pass

    def publish(self, message_id, *messageParts):
        pass

    def set(self, message_id, message):
        """
        """
        assigned_node = self._node_manager.get_node_for_key(
            message['key'])
        message['assigned_node'] = assigned_node
        wait = message.get('wait_on_publish', True)
        if wait:
            d = self._publisher.publish(message, tag=b'fanout')
            d.addCallback(lambda _: True)
            return d
        else:
            return defer.succeed(True)

    # def get(self, message_id, message):
    #     pass

    # def remove(self, message_id, message):
    #     pass


def run_broker():
    log.startLogging(sys.stdout)
    # Broker(zf, e, debug=True)
    Broker.create('ipc:///tmp/broker.sock', debug=True)
    reactor.run()

if __name__ == '__main__':
    run_broker()
