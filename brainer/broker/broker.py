# -*- coding: utf8 -*-
import sys
import umsgpack

from twisted.python import log
from twisted.internet import reactor, defer

from txzmq import ZmqREPConnection, ZmqEndpoint, ZmqFactory, ZmqREQConnection

from replica import Publisher

from lib.base import BaseREP
from lib.hash import ConsistentHash
from lib.mixins import SerializerMixin


class NodeClient(ZmqREQConnection, SerializerMixin):
    def __init__(self, factory, endpoint, *args, **kwargs):
        """A Node Client.

        :param factory: A `txzmq.ZmqFactory` object.
        :param endpoint: A `txzmq.ZmqEndpoint` object.
        """
        self.node_number = kwargs['node_number']
        self._serializer = kwargs.pop('serializer', umsgpack)
        super(NodeClient, self).__init__(factory, endpoint)

    @classmethod
    def create(cls, address, node_number):
        factory = ZmqFactory()
        endpoint = ZmqEndpoint('connect', address)
        return cls(factory, endpoint, node_number=node_number)

    def sendMsg(self, message):
        """
        """
        d = super(NodeClient, self).sendMsg(
            self.pack(message))
        d.addCallback(lambda reply: self.unpack(reply[0]))
        return d

    def get(self, message):
        return self.sendMsg(message)

    def set(self, message):
        return self.sendMsg(message)

    def remove(self, message):
        return self.sendMsg(message)


class Broker(BaseREP, SerializerMixin):
    """
    """
    def __init__(self, factory, endpoint, *args, **kwargs):
        """
        :param factory: A `txzmq.ZmqFactory` object.
        :param endpoint: A `txzmq.ZmqEndpoint` object.
        :param node_manager: A Node Manager. Defaults to `NodeManager`.
        :param serializer: A serializer, defaults to umsgpack.
        :param debug: If True, will log debug messages. Defaults to False.
        """
        self._serializer = kwargs.pop('serializer', umsgpack)
        self._debug = kwargs.pop('debug', False)

        self._nodes = []
        self._nodes_id = {}
        self._nodes_connections = {}

        self.replication = kwargs.get('replication', True)

        log.msg('Broker started!!! Serializer: {}'.format(
            self._serializer.__name__))

        self._publisher = Publisher.create(
            kwargs.get('publisher_host', 'ipc:///tmp/publisher.sock'),
            debug=self._debug)

        self._allowed_actions = (
            'register', 'unregister', 'ping',
            'route', 'set', 'get', 'remove')

        super(Broker, self).__init__(factory, endpoint)

    def register_node(self, server_id, address):
        node_number = len(self._nodes)
        self._nodes.append(node_number)
        self._nodes_id[node_number] = server_id

        node_connection = NodeClient.create(address, node_number)
        self._nodes_connections[server_id] = node_connection
        return node_number

    def unregister_node(self, node_number, server_id=None):
        self._nodes.remove(node_number)

    def get_node_by_key(self, key):
        hashing = ConsistentHash(len(self._nodes))
        node_number = hashing.get_machine(key)
        server_id = self._nodes_id[node_number]
        return self._nodes_connections[server_id]

    def gotMessage(self, message_id, *messageParts):
        """Any message received is processed here.

        :param message_id: The message id (Generated by ZeroMQ).
        :param messageParts: The message itself.
        """
        message = self.unpack(messageParts[0])
        if self._debug:
            log.msg("New Message: {}".format(message))

        action = message['action']
        if action not in self._allowed_actions:
            self.reply_error("FORBBIDEN")

        method = getattr(self, action, None)
        if method is None:
            self.reply_error("NOT_IMPLEMENTED")

        method(message_id, message)

    def register(self, message_id, message):
        node_number = self.register_node(message['id'], message['address'])
        self.reply(message_id, {"action": "register", "node": node_number})

    def unregister(self, message_id, message):
        node, server_id = message['node'], message['id']
        if self._debug:
            log.msg(
                'Unregister request received for node number {}'.format(node))
        self.unregister_node(node, server_id)
        self.reply(message_id, {"action": "unregister", "unregistered": True})

    def route(self, message_id, *messageParts):
        pass

    def publish(self, message):
        self._publisher.publish(message, tag=b'fanout')
        return defer.succeed(True)

    def set(self, message_id, message):
        """
        """
        node = self.get_node_by_key(message['key'])
        wait = message.get('wait', True)
        if wait:
            dset = node.set(message)
        else:
            reply = {'action': 'set'}
            dset = defer.succeed(reply)

        if self.replication:
            message['assigned_node'] = node.node_number
            self.publish(message)

        dset.addCallback(lambda reply: self.reply(message_id, reply))
        return dset

    def get(self, message_id, message):
        node = self.get_node_by_key(message['key'])
        d = node.get(message)
        d.addCallback(lambda reply: self.reply(message_id, reply))
        return d

    def remove(self, message_id, message):
        pass


def run_broker():
    log.startLogging(sys.stdout)
    # Broker(zf, e, debug=True)
    Broker.create('ipc:///tmp/broker.sock', debug=True)
    reactor.run()

if __name__ == '__main__':
    run_broker()
