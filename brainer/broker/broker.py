# -*- coding: utf8 -*-
import sys
import umsgpack

from twisted.python import log
from twisted.internet import reactor, defer

from txzmq import ZmqEndpoint, ZmqFactory, ZmqREQConnection

from replica import Publisher

from lib.base import BaseREP
from lib.hash import ConsistentHash
from lib.mixins import SerializerMixin
from lib.exceptions import ZeroNodeError


class NodeClient(ZmqREQConnection, SerializerMixin):
    def __init__(self, factory, endpoint, *args, **kwargs):
        """A Node Client.

        :param factory: A `txzmq.ZmqFactory` object.
        :param endpoint: A `txzmq.ZmqEndpoint` object.
        """
        self._serializer = kwargs.pop('serializer', umsgpack)
        self._timeout = kwargs.pop('timeout', 5)
        super(NodeClient, self).__init__(factory, endpoint)

    @classmethod
    def create(cls, address):
        factory = ZmqFactory()
        endpoint = ZmqEndpoint('connect', address)
        return cls(factory, endpoint)

    def _on_error(self, f):
        """Log a failure and re-raise it.

        :param f: A `twisted.python.failure.Failure` object.
        """
        log.err(
            f,
            'Something happened speaking with node {} (timeout: {}).'.format(
                self.node_number, self._timeout))
        raise f

    def sendMsg(self, message):
        """Sends a message.

        :param message: Message to be sent.
        """
        d = super(NodeClient, self).sendMsg(
            self.pack(message), timeout=self._timeout)
        d.addCallback(lambda reply: self.unpack(reply[0]))
        d.addErrback(self._on_error)
        return d

    def get(self, message):
        return self.sendMsg(message)

    def set(self, message):
        return self.sendMsg(message)

    def remove(self, message):
        return self.sendMsg(message)


class Broker(BaseREP, SerializerMixin):
    """
    """
    def __init__(self, factory, endpoint, *args, **kwargs):
        """
        :param factory: A `txzmq.ZmqFactory` object.
        :param endpoint: A `txzmq.ZmqEndpoint` object.
        :param node_manager: A Node Manager. Defaults to `NodeManager`.
        :param serializer: A serializer, defaults to umsgpack.
        :param debug: If True, will log debug messages. Defaults to False.
        """
        self._serializer = kwargs.pop('serializer', umsgpack)
        self._debug = kwargs.pop('debug', False)
        self._publisher_address = kwargs.get(
            'publisher', 'ipc:///tmp/publisher.sock')

        # A list of node-ids, the index is the node_number
        self._nodes = []
        # Key: Value = node-id: connection obj
        self._nodes_connections = {}

        self.replication = kwargs.get('replication', True)

        log.msg('Broker started!!! Serializer: {}'.format(
            self._serializer.__name__))

        self._publisher = Publisher.create(
            self._publisher_address, debug=self._debug)

        self._allowed_actions = (
            'register', 'unregister', 'ping',
            'route', 'set', 'get', 'remove')

        super(Broker, self).__init__(factory, endpoint)

    def register_node(self, node_id, address):
        """
        :param node_id: The node id sent down by the Node.
        """
        self._nodes.append(node_id)
        node_number = self._nodes.index(node_id)

        node_connection = NodeClient.create(address)
        self._nodes_connections[node_id] = node_connection
        return node_number

    def clean_connection(self, node_id):
        """
        :param node_id: The node id sent down by the Node.
        """
        connection = self._nodes_connections[node_id]
        connection.shutdown()
        del self._nodes_connections[node_id]

    def unregister_node(self, node_id):
        """Entry-point for unregistering a node.
        It shuts down the connection, removes it from the list of nodes
        and kicks off the process of redistributing keys on the remaining
        nodes.
        """
        self.clean_connection(node_id)
        self._nodes.remove(node_id)
        self.redistribute(node_id)

    def redistribute(self, node_id):
        if not self._nodes:
            log.msg('All nodes are down. No keys to redistribute.')
            return
        log.msg('Node {} is down, redistributing keys.'.format(node_id))

    def get_node_by_key(self, key):
        """
        :param key: The key to be set. It will be used to define which
        node that key should go.
        """
        if not self._nodes:
            raise ZeroNodeError

        hashing = ConsistentHash(len(self._nodes))
        node_number = hashing.get_machine(key)
        node_id = self._nodes[node_number]
        return self._nodes_connections[node_id]

    def gotMessage(self, message_id, *messageParts):
        """Any message received is processed here.

        :param message_id: The message id (Generated by ZeroMQ).
        :param messageParts: The message itself.
        """
        message = self.unpack(messageParts[0])
        if self._debug:
            log.msg("New Message: {}".format(message))

        action = message['action']
        if action not in self._allowed_actions:
            self.reply_error(
                message_id, "FORBBIDEN", "You cannot run this command.")

        method = getattr(self, action, None)
        if method is None:
            self.reply_error(
                message_id, "NOT_IMPLEMENTED", "Command not implemented.")

        try:
            d = defer.maybeDeferred(method, message_id, message)
        except ZeroNodeError:
            self.reply_error(
                message_id, "ZERO_NODES", "There are no nodes registered.")
            return

        d.addErrback(self._on_error, method, message_id)

    def _on_error(self, f, method, message_id):
        """On error, we reply a failure to the customer.

        This is not proper failure handling. Needs to be improved.

        :param f: A `twisted.python.failure.Failure`.
        :param method: The method that the client requested.
        :param message_id: The request message id.
        """
        log.err(f, "Method {} failed.".format(method))
        self.reply_error(message_id, "UNKNOWN_ERROR", "Verify server log")

    def register(self, message_id, message):
        node_number = self.register_node(message['id'], message['address'])
        self.reply(message_id, {"action": "register", "node": node_number})

    def unregister(self, message_id, message):
        node_id = message['id']
        if self._debug:
            log.msg(
                'Unregister request received for node ID {}'.format(node_id))
        self.unregister_node(node_id)
        self.reply(message_id, {"action": "unregister", "unregistered": True})

    def route(self, message_id, *messageParts):
        pass

    def publish(self, message):
        self._publisher.publish(message, tag=b'fanout')
        return defer.succeed(True)

    def set(self, message_id, message):
        """
        """
        node = self.get_node_by_key(message['key'])
        wait = message.get('wait', True)
        if wait:
            dset = node.set(message)
        else:
            reply = {'action': 'set'}
            dset = defer.succeed(reply)

        if self.replication:
            self.publish(message)

        dset.addCallback(lambda reply: self.reply(message_id, reply))
        return dset

    def get(self, message_id, message):
        node = self.get_node_by_key(message['key'])
        d = node.get(message)
        d.addCallback(lambda reply: self.reply(message_id, reply))
        return d

    def remove(self, message_id, message):
        pass


def run_broker(host, publisher, debug=False):
    log.startLogging(sys.stdout)
    Broker.create(host, publisher=publisher, debug=debug)
    reactor.run()

if __name__ == '__main__':
    run_broker()
